## 전반적인 방향

최대한 이전 프로젝트에서 쓰지 않은 기술들을 사용하려고 했습니다.

## React 대신 Web API

### 사용 이유

저는 React도 잘 다뤄야 하지만 Web API도 잘 다뤄야 한다고 생각합니다. 이렇게 생각하는 이유들은 다음과 같습니다. 첫 번째 이유는 이를 잘 다뤄야 React의 장점을 알 수 있다는 점입니다. 두 번째 이유는 React가 아닌 다른 프레임워크를 사용할 수도 있다는 점입니다.

### 단점

JSX를 쓰지 않고 createElement를 쓰니 가독성이 떨어졌습니다.

## SCSS

### 사용 이유

많은 기업에서 이를 요구하길래 도입했습니다.

### 장점

변수 기능을 사용할 수 있습니다. 하지만 지금 시점에서는 장점은 아닌 것 같습니다. 왜냐하면 현재 CSS도 변수 기능을 지원하기 때문입니다. 물론 IE가 이를 지원하지 않지만, 현재는 IE를 많이 쓰지 않고 있다고 생각합니다.

모듈 기능을 사용할 수 있습니다. CSS도 @import를 사용해서 모듈화를 할 수 있습니다. 다만 변수를 그냥 가져오는 CSS의 @import와 달리 SCSS의 @use는 namespace를 사용합니다. 이는 여러 장점이 있는데요. 첫 번째는 쉽게 변수의 출처를 알 수 있다는 점입니다. 두 번째는 다른 모듈에 같은 이름의 변수를 써도 된다는 점입니다.

parent selector를 사용할 수 있습니다. 이는 코드의 가독성을 높입니다.

## Jest 대신 Vitest

사용한 이유는 다음과 같습니다.

- Jest보다 Vitest를 더 많이 배웠기 때문입니다.

- 앞으로 Vitest는 사용량이 늘고, Jest는 사용량이 줄 것이라 생각했기 때문입니다.

- Vitest는 Jest와 유사합니다. 만약 회사에서 Jest를 쓰더라도 별 어려움 없이 쓸 수 있다고 생각합니다.

- ES Module을 default로 씁니다. Jest에서도 ES Module을 쓸 수 있는지를 알아보았는데요. Node.js의 버전이 높아야 한다고 합니다.

- '테스트'라는 환경 때문입니다. 2022년 10월 24일 기준으로 아직도 버전이 1을 넘지 않았습니다. 하지만 테스트라는 환경이 실제로 배포에 반영되지 않으므로 조금 오류가 있어도 괜찮다고 생각을 했습니다.

- Jest로 모듈을 mocking하는 방법을 몰랐기 때문입니다. 공식 문서를 보니 CommonJS가 아닌 ES Module을 쓰더라고요. 그래서 알아내려면 시간이 걸리기 때문에 Vitest를 썼습니다. (현재는 알아낸 상태입니다.)

## Webpack

번들링을 하기 위해 Webpack을 사용했고, 다양한 기능을 활용했습니다. 그 기능들은 다음과 같습니다.

- dev server: 제가 무엇인가를 수정하면 바로 반영이 되게 하기 위해서 사용했습니다. 다만 Vite와 비교하면 시간이 느립니다.

- 스타일 관련: 앞서 언급했듯이 SCSS를 사용했기 때문에 'sass-loader'를 사용했고요. production을 할 때는 'mini-css-extract-plugin'을 사용했고, 개발을 할 때는 (dev server를 쓸 때는) 'style-loader'를 사용했습니다. 이렇게 적용되는 패키지를 나눈 이유는 다음과 같습니다. 개발을 할 때는 애초에 CSS 파일을 만들어서 쓸 수가 없고요. production을 할 때는 혹시나 생길 수 있는 Cumulative Layout Shift를 막기 위해서입니다. 다른 프로젝트에서 styled-components를 쓴 적이 있는데, 이 현상이 심해서 이렇게 했습니다. 그런데 여기에서는 이 현상이 없는 것 같습니다. production 모드와 개발 모드는 .env 파일을 통해 조절했습니다.

- 타입스크립트: Babel을 사용했습니다.

## GitHub Actions

CI(Continuous Integration)를 하기 위해 썼습니다. Vitest를 활용한 테스트가 포함되어 있습니다.
